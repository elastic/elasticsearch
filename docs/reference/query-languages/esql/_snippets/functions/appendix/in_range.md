% This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.

### Lucene pushdown optimization [esql-in_range-pushdown]

The `IN_RANGE` function supports Lucene pushdown optimization in two scenarios, which can provide significant performance improvements (10-100x faster) for selective queries:

**Case 1: Date field + constant range**

When filtering on an indexed date field with a constant range:

```esql
FROM employees
| WHERE IN_RANGE(hire_date, TO_DATE_RANGE("1985-01-01..1986-01-01"))
```

The query is pushed down to Lucene as a range query, allowing Lucene to use its index to find matching documents efficiently. Only matching documents are loaded, avoiding compute-layer filtering.

**Case 2: Constant date + range field**

When filtering on an indexed range field with a constant date:

```esql
FROM date_ranges
| WHERE IN_RANGE(TO_DATETIME("2024-06-15"), date_range)
```

The query uses a range query with the `CONTAINS` relation to check if the indexed range field contains the constant date point. This leverages Lucene's range field index for efficient filtering.

**Pushdown in LOOKUP JOIN contexts**

`IN_RANGE` can be used effectively in `LOOKUP JOIN` scenarios:

- When the date is from the left side and the range is constant, pushdown works (Case 1)
- When the range is from the lookup index and the date is constant, pushdown works (Case 2)
- When both date and range come from different sides of the join, pushdown is not possible because values aren't known until after the join

**Key requirement**: Pushdown works when one argument is a constant (foldable) and the other argument is an indexed field from the table being scanned.

**Not supported**: Field-to-field comparisons (e.g., `IN_RANGE(date_field, range_field)`) require per-document evaluation and cannot be fully pushed down to Lucene.

[[release-highlights]]
== What's new in {minor-version}

Here are the highlights of what's new and improved in {es} {minor-version}!
ifeval::["{release-state}"!="unreleased"]
For detailed information about this release, see the <<es-release-notes>> and
<<breaking-changes>>.

// Add previous release to the list
Other versions:

{ref-bare}/8.10/release-highlights.html[8.10]
| {ref-bare}/8.9/release-highlights.html[8.9]
| {ref-bare}/8.8/release-highlights.html[8.8]
| {ref-bare}/8.7/release-highlights.html[8.7]
| {ref-bare}/8.6/release-highlights.html[8.6]
| {ref-bare}/8.5/release-highlights.html[8.5]
| {ref-bare}/8.4/release-highlights.html[8.4]
| {ref-bare}/8.3/release-highlights.html[8.3]
| {ref-bare}/8.2/release-highlights.html[8.2]
| {ref-bare}/8.1/release-highlights.html[8.1]
| {ref-bare}/8.0/release-highlights.html[8.0]

endif::[]

// tag::notable-highlights[]

[discrete]
[[es_ql_new_query_language_for_flexible_iterative_analytics_in_technical_preview]]
=== ES|QL â€” a new query language for flexible, iterative analytics in technical preview
As the Elastic Platform has become more widely adopted for search, security, observability, and general analytics,
analyst users require the ability to take data-as-ingested, transform it to fit their investigative needs
post-ingestion, and derive insights from underlying Elasticsearch index data. They need a concise, integrated,
and efficient workflow enabled by rich and expressive queries where search, filter, aggregation,
and transformation are performed via a single query expression with little-to-no UI context switching.

To solve these challenges, the Elastic team is developing the <<esql,Elasticsearch Query Language (ES|QL)>>.
ES|QL provides Elastic users with a flexible, powerful, and robust query expression language to interrogate data.
ES|QL also provides a superior query UX with post-ingest processing capabilities that fundamentally transforms
and expands the analytics and data processing capabilities of Elasticsearch.

ES|QL introduces distributed compute capabilities to users in disparate roles and with varying skill levels.
These compute capabilities enable ES|QL to simplify user workflows in several key ways.

* Utilize a superior query UX: ES|QL query expressions support complex analytics and data processing.
  They are easy to learn, read, and share.
* Use the filter, aggregation, and transformation capabilities of Elasticsearch with subqueries and lookups,
  made possible by new Elasticsearch compute and data processing capabilities.
* Use ES|QL across Kibana in Discover, Kibana Lens, and Elastic Solutions, giving you seamless workflows.
  You will be able to visualize ES|QL queries, share them with teams on dashboards or as queries,
  and use queries to create custom alerts.
* In {security-guide}/whats-new.html[{elastic-sec}], create an {esql} rule and use {esql} to investigate events in Timeline. Use the AI Assistant to write queries, or answer questions about the {esql} query language.

[role="screenshot"]
image:images/esql/esql_kibana_discover_logs.png[ES|QL usage in Kibana Discover for Analysing Proxy Logs]

{es-pull}98309[#98309]

[discrete]
[[data_stream_lifecycle_in_technical_preview]]
=== The data stream lifecycle is now in Technical Preview
This marks the data stream lifecycle as available in Technical Preview. Data streams will be able to take advantage of a built-in simplified and resilient lifecycle implementation. Data streams with a configured lifecycle will be automatically rolled over and tail merged (a forcemerge implementation that's lightweight and only merges the long tail of small segments instead of the whole shard). With the shard and index maintenance tasks being handled automatically to ensure optimum performance, and trade-off between indexing and searching, you'll be able to focus on the business related lifecycle aspects like data retention.

{es-pull}100187[#100187]

// end::notable-highlights[]


[discrete]
[[use_indexwriter_flushnextbuffer_to_reclaim_memory_from_indexing_buffers]]
=== Use `IndexWriter.flushNextBuffer()` to reclaim memory from indexing buffers
Rather than forcing a refresh to reclaim memory from indexing buffers, which flushes all
segments no matter how large, Elasticsearch now takes advantage of
`IndexWriter#flushNextBuffer` which only flushes the largest pending segment. This should smooth
out indexing allowing for larger segment sizes, fewer merges and higher throughput.

Furthermore, the selection algorithm to pick which shard to reclaim memory from next was
changed, from picking the shard that uses the most RAM to going over shards in a round-robin
fashion. This approach has proved to work significantly better in practice.

{es-pull}94607[#94607]

.Elastic Search Labs
****
Bookmark the https://search-labs.elastic.co/search-labs[Elastic Search Labs webpage] for technical content about building search experiences powered by {es}'s vector search capabilities and generative AI.

The companion https://github.com/elastic/elasticsearch-labs[`elasticearch-labs` GitHub repository] contains the source code for a number of sample apps, as well as executable Python notebooks.
****

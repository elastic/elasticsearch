[[high-cpu-usage]]
=== High CPU usage

{es} uses <<modules-threadpool,thread pools>> to manage CPU resources for
concurrent operations. High CPU usage typically means one or more thread pools
are running low.

If a thread pool is depleted, {es} will <<rejected-requests,reject requests>>
related to the thread pool. For example, if the `search` thread pool is
depleted, {es} will reject search requests until more threads are available.

****
If you're using Elastic Cloud Hosted, then you can use AutoOps to monitor your cluster. AutoOps significantly simplifies cluster management with performance recommendations, resource utilization visibility, real-time issue detection and resolution paths. For more information, refer to https://www.elastic.co/guide/en/cloud/current/ec-autoops.html[Monitor with AutoOps].
****

[discrete]
[[diagnose-high-cpu-usage]]
==== Diagnose high CPU usage

**Check CPU usage**

You can check the CPU usage per node using the <<cat-nodes,cat nodes API>>:

// tag::cpu-usage-cat-nodes[]
[source,console]
----
GET _cat/nodes?v=true&s=cpu:desc
----

The response's `cpu` column contains the current CPU usage as a percentage.
The `name` column contains the node's name. Elevated but transient CPU usage is
normal. However, if CPU usage is elevated for an extended duration, it should be
investigated.

To track CPU usage over time, we recommend enabling monitoring:

include::{es-ref-dir}/tab-widgets/cpu-usage-widget.asciidoc[]

**Check hot threads**

If a node has high CPU usage, use the <<cluster-nodes-hot-threads,nodes hot
threads API>> to check for resource-intensive threads running on the node.

[source,console]
----
GET _nodes/hot_threads
----
// TEST[s/\/my-node,my-other-node//]

This API returns a breakdown of any hot threads in plain text. High CPU usage
frequently correlates to <<task-queue-backlog,a long-running task, or a
backlog of tasks>>.

[discrete]
[[reduce-cpu-usage]]
==== Reduce CPU usage

The following tips outline the most common causes of high CPU usage and their
solutions.

**Check JVM garbage collection**

High CPU usage is often caused by excessive JVM garbage collection (GC) activity. This excessive GC typically arises from configuration problems or inefficient queries causing increased heap memory usage.

For optimal JVM performance, garbage collection should meet these criteria:

1. Young GC completes quickly (ideally within 50 ms).
2. Young GC does not occur too frequently (approximately once every 10 seconds).
3. Old GC completes quickly (ideally within 1 second).
4. Old GC does not occur too frequently (once every 10 minutes or less frequently).

Excessive JVM garbage collection usually indicates high heap memory usage. Common potential reasons for increased heap memory usage include:

* Oversharding of indices
* Very large aggregation queries
* Excessively large bulk indexing requests
* Inefficient or incorrect mapping definitions
* Improper heap size configuration
* Misconfiguration of JVM new generation ratio (-XX:NewRatio)

**Hot spotting**

You might experience high CPU usage on specific data nodes or an entire <<data-tiers,data tier>> if traffic isn’t evenly distributed—a scenario known as <<hot spotting,hot spotting>>. This commonly occurs when read or write applications don’t properly balance requests across nodes, or when indices receiving heavy write activity (like hot-tier indices) have their shards concentrated on just one or a few nodes.

For details on diagnosing and resolving these issues, see <<hot spotting,hot spotting>>.

**Oversharding**

If your Elasticsearch cluster contains a large number of shards, you might be facing an oversharding issue.

Oversharding occurs when there are too many shards, causing each shard to be smaller than optimal. While Elasticsearch doesn’t have a strict minimum shard size, an excessive number of small shards can negatively impact performance. Each shard consumes cluster resources since Elasticsearch must maintain metadata and manage shard states across all nodes.

If you have too many small shards, you can address this by:

* Removing empty or unused indices.
* Deleting or closing indices containing outdated or unnecessary data.
* Reindexing smaller shards into fewer, larger shards to optimize cluster performance.

See <<size-your-shards,Size your shards>> for more information.

==== Additional recommendations

To further reduce CPU load or mitigate temporary spikes in resource usage, consider these steps:

* Scale your cluster: Heavy indexing and search loads can deplete smaller thread pools.Add nodes or upgrade existing ones to handle increased indexing and search loads more effectively.
* Spread out bulk requests: Submit smaller <<docs-bulk,bulk indexing>> or multi-search requests and space them out to avoid overwhelming thread pools.
* Cancel long-running searches: Regularly use the task management API to identify and cancel searches that consume excessive CPU time. To check
for these searches, use the <<tasks,task management API>>.

[source,console]
----
GET _tasks?actions=*search&detailed
----

The response's `description` contains the search request and its queries.
`running_time_in_nanos` shows how long the search has been running.

[source,console-result]
----
{
  "nodes" : {
    "oTUltX4IQMOUUVeiohTt8A" : {
      "name" : "my-node",
      "transport_address" : "127.0.0.1:9300",
      "host" : "127.0.0.1",
      "ip" : "127.0.0.1:9300",
      "tasks" : {
        "oTUltX4IQMOUUVeiohTt8A:464" : {
          "node" : "oTUltX4IQMOUUVeiohTt8A",
          "id" : 464,
          "type" : "transport",
          "action" : "indices:data/read/search",
          "description" : "indices[my-index], search_type[QUERY_THEN_FETCH], source[{\"query\":...}]",
          "start_time_in_millis" : 4081771730000,
          "running_time_in_nanos" : 13991383,
          "cancellable" : true
        }
      }
    }
  }
}
----
// TESTRESPONSE[skip: no way to get tasks]

To cancel a search and free up resources, use the API's `_cancel` endpoint.

[source,console]
----
POST _tasks/oTUltX4IQMOUUVeiohTt8A:464/_cancel
----

For additional tips on how to track and avoid resource-intensive searches, see
<<avoid-expensive-searches,Avoid expensive searches>>.
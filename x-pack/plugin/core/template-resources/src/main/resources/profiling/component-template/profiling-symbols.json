{
  "template": {
    "settings": {
      "index": {
        "number_of_shards": "16",
        "number_of_replicas": 0,
        "auto_expand_replicas": "0-1",
        "refresh_interval": "10s",
        "hidden": true
      }
    },
    "mappings": {
      /*
       Enable source for now because ip_range is not supported by synthetic source.
       And we currently want to use the reindex API for experiments with storage costs.
      */
      "_source": {
        "enabled": true
      },
      "_meta": {
        "index-template-version": ${xpack.profiling.template.version},
        "index-version": ${xpack.profiling.index.symbols.version}
      },
      "dynamic": false,
      "properties": {
        "ecs.version": {
          "type": "keyword",
          "index": true,
          "doc_values": false,
          "store": false
        },
        /* name of the function */
        "Symbol.function.name": {
          "type": "keyword",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* file path */
        "Symbol.file.name": {
          "type": "keyword",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* (for inlined functions) file path where inline function was called */
        "Symbol.call.file.name": {
          "type": "keyword",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* (for inlined functions) line where inline function was called */
        "Symbol.call.line": {
          "type": "integer",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* function start line (only available from DWARF). Currently unused. */
        "Symbol.function.line": {
          "type": "integer",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* inline depth */
        "Symbol.depth": {
          "type": "integer",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /*
         pairs of (32bit PC offset, 32bit line number) followed by 64bit PC range base at the end.
         To find line number for a given PC: find lowest offset such as offsetBase+PC >= offset, then read corresponding line number.
         offsetBase could seemingly be available from exec_pc_range (it's the first value of the pair), but it's not the case.
         Ranges are stored as points, which cannot be retrieve when disabling _source.
         See https://www.elastic.co/guide/en/elasticsearch/reference/current/point.html .

         Linetable: base for offsets (64bit PC range base)
        */
        "Symbol.linetable.base": {
          "type": "unsigned_long",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* Linetable: length of range (PC range is [base, base+length)) */
        "Symbol.linetable.length": {
          "type": "unsigned_long",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* Linetable: concatenated offsets (each value is ULEB128encoded) */
        "Symbol.linetable.offsets": {
          "type": "keyword",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* Linetable: concatenated lines (each value is ULEB128 encoded) */
        "Symbol.linetable.lines": {
          "type": "keyword",
          "index": false,
          "doc_values": false,
          "store": false
        },
        /* fileID. used for deletion and Symbol.exec.pcrange collision handling on symbolization */
        "Symbol.file.id": {
          "type": "keyword",
          "index": true,
          "doc_values": false,
          "store": false
        },
        /* PC ranges [begin, end) */
        "Symbol.exec.pcrange": {
          "type": "ip_range",
          "index": true,
          "doc_values": false,
          "store": false
        }
      }
    }
  },
  "version": ${xpack.profiling.template.version}
}

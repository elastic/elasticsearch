//
// CSV spec for FUSE command
//

simpleFuse
required_capability: fork_v9
required_capability: fuse_v6
required_capability: match_operator_colon

FROM employees METADATA _id, _index, _score
| FORK ( WHERE emp_no:10001 )
       ( WHERE emp_no:10002 )
| FUSE
| EVAL _score = round(_score, 4)
| KEEP _score, _fork, emp_no
| SORT _score, _fork, emp_no
;

_score:double | _fork:keyword | emp_no:integer
0.0164        | fork1         | 10001
0.0164        | fork2         | 10002
;

fuseWithMatchAndScore
required_capability: fork_v9
required_capability: fuse_v6
required_capability: match_operator_colon
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.03279       | [fork1, fork2] | 4
0.01613       | fork1          | 56
0.01613       | fork2          | 60
0.01587       | fork1          | 26
0.01587       | fork2          | 29
;

fuseWithDisjunctionAndPostFilter
required_capability: fork_v9
required_capability: fuse_v6
required_capability: match_operator_colon
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" OR author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
| WHERE _score > 0.014
;

_score:double | _fork:keyword  | _id:keyword
0.03252       | [fork1, fork2] | 60
0.032         | [fork1, fork2] | 29
0.01639       | fork2          | 4
0.01587       | fork1          | 1
;

fuseWithStats
required_capability: fork_v9
required_capability: fuse_v6
required_capability: match_operator_colon

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Ursula K. Le Guin" AND title:"short stories" | SORT _score, _id DESC | LIMIT 3)
| FUSE
| STATS count_fork=COUNT(*) BY _fork
| SORT _fork
;

count_fork:long | _fork:keyword
3               | fork1
3               | fork2
1               | fork3
;

fuseWithMultipleForkBranches
required_capability: fork_v9
required_capability: fuse_v6
required_capability: match_operator_colon
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK (WHERE author:"Keith Faulkner" AND qstr("author:Rory or author:Beverlie") | SORT _score, _id DESC | LIMIT 3)
       (WHERE author:"Ursula K. Le Guin" | SORT _score, _id DESC | LIMIT 3)
       (WHERE title:"Tolkien" AND author:"Tolkien" AND year > 2000 AND mv_count(author) == 1 | SORT _score, _id DESC | LIMIT 3)
       (WHERE match(author, "Keith Faulkner") AND match(author, "Rory Tyger") | SORT _score, _id DESC | LIMIT 3)
| FUSE
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 4)
| EVAL title = trim(substring(title, 1, 20))
| KEEP _score, author, title, _fork
;

_score:double | author:keyword                    | title:keyword        | _fork:keyword
0.0325        | [Keith Faulkner, Rory Tyger]      | Pop! Went Another Ba | [fork1, fork4]
0.0164        | J.R.R. Tolkien                    | Letters of J R R Tol | fork3
0.0164        | [Beverlie Manson, Keith Faulkner] | Rainbow's End: A Mag | fork1
0.0164        | Ursula K. Le Guin                 | Worlds of Exile and  | fork2
0.0161        | Ursula K. Le Guin                 | The Word For World i | fork2
0.0159        | Ursula K. Le Guin                 | Steering the Craft   | fork2
;

fuseWithSemanticSearch
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score

FROM semantic_text METADATA _id, _score, _index
| FORK ( WHERE semantic_text_field:"something" | SORT _score DESC | LIMIT 2)
       ( WHERE semantic_text_field:"something else" | SORT _score DESC | LIMIT 2)
| FUSE
| SORT _score DESC, _id, _index
| EVAL _score = round(_score, 4)
| EVAL _fork = mv_sort(_fork)
| KEEP _fork, _score, _id, semantic_text_field
;

_fork:keyword  | _score:double | _id:keyword | semantic_text_field:keyword
[fork1, fork2] | 0.0328        | 2           | all we have to decide is what to do with the time that is given to us
[fork1, fork2] | 0.0323        | 3           | be excellent to each other
;

fuseWithSimpleRrf
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE rrf
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.03279       | [fork1, fork2] | 4
0.01613       | fork1          | 56
0.01613       | fork2          | 60
0.01587       | fork1          | 26
0.01587       | fork2          | 29
;

fuseWithRrfAndRankConstant
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE rrf WITH {"rank_constant": 50 }
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.03922       | [fork1, fork2] | 4
0.01923       | fork1          | 56
0.01923       | fork2          | 60
0.01887       | fork1          | 26
0.01887       | fork2          | 29
;

fuseWithRrfAndWeights
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE rrf WITH {"weights": { "fork1": 0.3, "fork2": 0.7 } }
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.01639       | [fork1, fork2] | 4
0.01129       | fork2          | 60
0.01111       | fork2          | 29
0.00484       | fork1          | 56
0.00476       | fork1          | 26
;

fuseWithRrfRankConstantAndWeights
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _score, _index
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
| FUSE rrf WITH {"rank_constant": 60, "weights": { "fork1": 0.3, "fork2": 0.7 } }
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.01639       | [fork1, fork2] | 4
0.01129       | fork2          | 60
0.01111       | fork2          | 29
0.00484       | fork1          | 56
0.00476       | fork1          | 26
;

fuseWithRrfAndScoreColumn
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL my_score = _score | DROP _score)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL my_score = _score | DROP _score)
| FUSE rrf SCORE by my_score
| SORT my_score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL my_score = round(my_score, 5)
| KEEP my_score, _fork, _id
;

my_score:double | _fork:keyword  | _id:keyword
0.03279       | [fork1, fork2] | 4
0.01613       | fork1          | 56
0.01613       | fork2          | 60
0.01587       | fork1          | 26
0.01587       | fork2          | 29
;

fuseWithRrfAndDiscriminatorColumn
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
| EVAL new_fork = _fork
| DROP _fork
| FUSE rrf GROUP BY new_fork
| SORT _score DESC, _id, _index
| EVAL new_fork = mv_sort(new_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, new_fork, _id
;

_score:double | new_fork:keyword  | _id:keyword
0.03279       | [fork1, fork2]    | 4
0.01613       | fork1             | 56
0.01613       | fork2             | 60
0.01587       | fork1             | 26
0.01587       | fork2             | 29
;

fuseWithRrfAndDiscriminatorColumnWithDots
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: dots_in_fuse
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
| EVAL new.fork = _fork
| DROP _fork
| FUSE rrf GROUP BY new.fork
| SORT _score DESC, _id, _index
| EVAL new.fork = mv_sort(new.fork)
| EVAL _score = round(_score, 5)
| KEEP _score, new.fork, _id
;

_score:double | new.fork:keyword  | _id:keyword
0.03279       | [fork1, fork2]    | 4
0.01613       | fork1             | 56
0.01613       | fork2             | 60
0.01587       | fork1             | 26
0.01587       | fork2             | 29
;

fuseWithRrfAndKeyColumns
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
| EVAL new_index = "lalala"
| FUSE rrf KEY BY new_id, new_index
| SORT _score DESC, new_id, new_index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, new_id
;

_score:double | _fork:keyword  | new_id:keyword
0.03279       | [fork1, fork2] | 44
0.01613       | fork1          | 5656
0.01613       | fork2          | 6060
0.01587       | fork1          | 2626
0.01587       | fork2          | 2929
;


fuseWithRrfAllOptionsScoreKeyAndGroupColumns
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3
        | EVAL new_id = CONCAT(_id, _id) | DROP _id)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
| EVAL new_fork = CASE (_fork == "fork1", "A", "B")
| EVAL new_score = _score * 2
| DROP _fork, _score
| FUSE rrf SCORE BY new_score KEY BY new_id GROUP BY new_fork WITH {"rank_constant": 60, "weights": { "fork1": 0.3, "fork2": 0.7 } }
| SORT new_score DESC, new_id
| EVAL new_fork = mv_sort(new_fork)
| EVAL new_score = round(new_score, 5)
| KEEP new_score, new_fork, new_id
;

new_score:double | new_fork:keyword | new_id:keyword
0.03279          | [A, B]           | 44
0.01613          | A                | 5656
0.01613          | B                | 6060
0.01587          | A                | 2626
0.01587          | B                | 2929
;

fuseWithSimpleLinear
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
2.09421       | fork1          | 26
2.08412       | [fork1, fork2] | 4
1.96182       | fork1          | 56
0.98906       | fork2          | 29
0.79763       | fork2          | 60
;

fuseWithLinearAndL2Norm

required_capability: fork_v9
required_capability: fuse_v6
required_capability: fuse_l2_norm
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear WITH {"normalizer": "l2_norm"}
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.89318       | [fork1, fork2] | 4
0.69946       | fork2          | 29
0.65012       | fork1          | 26
0.60902       | fork1          | 56
0.56408       | fork2          | 60
;

fuseWithLinearAndMinMax

required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear WITH {"normalizer": "minmax"}
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
1.0           | fork1          | 26
1.0           | fork2          | 29
0.79006       | fork1          | 56
0.4806        | fork2          | 60
0.0           | [fork1, fork2] | 4
;

fuseWithLinearAndWeights
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear WITH {"weights": { "fork1": 0.3, "fork2": 0.7 }}
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.87343       | [fork1, fork2] | 4
0.69234       | fork2          | 29
0.62826       | fork1          | 26
0.58855       | fork1          | 56
0.55834       | fork2          | 60
;

fuseWithLinearAndPartialWeights
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear WITH {"weights": { "fork1": 0.3, "inexistent": 0.7 }}
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
1.05958       | [fork1, fork2] | 4
0.98906       | fork2          | 29
0.79763       | fork2          | 60
0.62826       | fork1          | 26
0.58855       | fork1          | 56
;

fuseWithLinearWeightsAndMinMax
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 )
| FUSE linear WITH {"normalizer": "minmax", "weights": { "fork1": 0.3, "fork2": 0.7 }}
| SORT _score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, _id
;

_score:double | _fork:keyword  | _id:keyword
0.7           | fork2          | 29
0.33642       | fork2          | 60
0.3           | fork1          | 26
0.23702       | fork1          | 56
0.0           | [fork1, fork2] | 4
;


fuseWithLinearAndScoreColumn
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL my_score = _score | DROP _score)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL my_score = _score | DROP _score)
| FUSE linear SCORE BY my_score
| SORT my_score DESC, _id, _index
| EVAL _fork = mv_sort(_fork)
| EVAL my_score = round(my_score, 5)
| KEEP my_score, _fork, _id
;

my_score:double | _fork:keyword  | _id:keyword
2.09421         | fork1          | 26
2.08412         | [fork1, fork2] | 4
1.96182         | fork1          | 56
0.98906         | fork2          | 29
0.79763         | fork2          | 60
;


fuseWithLinearAndDiscriminatorColumn
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _index, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3)
| EVAL new_fork = _fork
| DROP _fork
| FUSE linear GROUP BY new_fork
| SORT _score DESC, _id, _index
| EVAL new_fork = mv_sort(new_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, new_fork, _id
;

_score:double | new_fork:keyword | _id:keyword
2.09421       | fork1            | 26
2.08412       | [fork1, fork2]   | 4
1.96182       | fork1            | 56
0.98906       | fork2            | 29
0.79763       | fork2            | 60
;

fuseWithLinearAndKeyColumns
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
| EVAL new_index = "lalala"
| FUSE LINEAR KEY BY new_id, new_index
| SORT _score DESC, new_id, new_index
| EVAL _fork = mv_sort(_fork)
| EVAL _score = round(_score, 5)
| KEEP _score, _fork, new_id
;

_score:double | _fork:keyword  | new_id:keyword
2.09421       | fork1          | 2626
2.08412       | [fork1, fork2] | 44
1.96182       | fork1          | 5656
0.98906       | fork2          | 2929
0.79763       | fork2          | 6060
;

fuseWithLinearAllOptionsScoreGroupAndKeyColumns
required_capability: fork_v9
required_capability: fuse_v6
required_capability: semantic_text_field_caps
required_capability: metadata_score
required_capability: routing_function_update

FROM books METADATA _id, _score
| FORK ( WHERE title:"Tolkien" | SORT _score, _id DESC | LIMIT 3
        | EVAL new_id = CONCAT(_id, _id) | DROP _id)
       ( WHERE author:"Tolkien" | SORT _score, _id DESC | LIMIT 3 | EVAL new_id = CONCAT(_id, _id) | DROP _id)
| EVAL new_fork = CASE (_fork == "fork1", "A", "B")
| EVAL new_score = _score * 2
| DROP _fork, _score
| FUSE LINEAR SCORE BY new_score KEY BY new_id GROUP BY new_fork WITH {"normalizer": "minmax", "weights": { "fork1": 0.3, "fork2": 0.7 }}
| SORT new_score DESC, new_id
| EVAL new_fork = mv_sort(new_fork)
| EVAL new_score = round(new_score, 5)
| KEEP new_score, new_fork, new_id
;

new_score:double | new_fork:keyword | new_id:keyword
1.0              | A                | 2626
1.0              | B                | 2929
0.79006          | A                | 5656
0.4806           | B                | 6060
0.0              | [A, B]           | 44
;


fuseWithRowAndRRF

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", _fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string)
| SORT my_score
| LIMIT 10
| FUSE RRF SCORE BY my_score
| SORT my_score DESC
| EVAL my_score = round(my_score, 5)
| KEEP _id, my_score
;

_id:keyword | my_score:double
id_0.0      | 0.01639
id_1.0      | 0.01613
id_2.0      | 0.01587
id_3.0      | 0.01563
id_4.0      | 0.01538
;

fuseWithRowLinearAndWeights

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", _fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string)
| SORT my_score
| LIMIT 10
| FUSE LINEAR SCORE BY my_score WITH { "weights": { "foo": 2 } }
| SORT my_score DESC
| KEEP _id, my_score
;

_id:keyword | my_score:double
id_4.0      | 8.0
id_3.0      | 6.0
id_2.0      | 4.0
id_1.0      | 2.0
id_0.0      | 0.0
;

fuseWithRowLinearAndMinMax

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", _fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string)
| SORT my_score
| LIMIT 10
| FUSE LINEAR SCORE BY my_score WITH { "normalizer": "minmax" }
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC
| KEEP _id, my_score
;

_id:keyword | my_score:double
id_4.0      | 1.0
id_3.0      | 0.75
id_2.0      | 0.5
id_1.0      | 0.25
id_0.0      | 0.0
;

fuseWithRowLinearAndL2Norm

required_capability: fuse_v6
required_capability: fuse_l2_norm

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", _fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string)
| SORT my_score
| LIMIT 10
| FUSE LINEAR SCORE BY my_score WITH { "normalizer": "l2_norm" }
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC
| KEEP _id, my_score
;

_id:keyword | my_score:double
id_4.0      | 0.7303
id_3.0      | 0.54772
id_2.0      | 0.36515
id_1.0      | 0.18257
id_0.0      | 0.0
;

fuseWithRowLinearAndMultiValueGroupColumn

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", my_fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string), my_fork = CASE(my_score == 0, ["foo", "bar"], my_fork)
| SORT my_score
| LIMIT 10
| FUSE LINEAR SCORE BY my_score GROUP BY my_fork
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC
| KEEP _id, my_score, my_fork
;

warning:Line 6:3: evaluation of [FUSE LINEAR SCORE BY my_score GROUP BY my_fork] failed, treating result as null. Only first 20 failures recorded.
warning:Line 6:3: java.lang.IllegalArgumentException: group column contains multivalued entries; assigning null scores

_id:keyword | my_score:double | my_fork:keyword
id_0.0      | null            | [foo, bar]
id_4.0      | 4.0             | foo
id_3.0      | 3.0             | foo
id_2.0      | 2.0             | foo
id_1.0      | 1.0             | foo
;

fuseWithRowLinearAndMultiValueScoreColumn

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", my_fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string), my_score = CASE(my_score == 0, [1, 2]::double, my_score)
| SORT my_score
| LIMIT 10
| FUSE LINEAR SCORE BY my_score GROUP BY my_fork
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC
| KEEP _id, my_score, my_fork
;

warning:Line 6:3: evaluation of [FUSE LINEAR SCORE BY my_score GROUP BY my_fork] failed, treating result as null. Only first 20 failures recorded.
warning:Line 6:3: java.lang.IllegalArgumentException: score column contains multivalued entries; assigning null scores

_id:keyword | my_score:double | my_fork:keyword
id_0.0      | null            | foo
id_4.0      | 4.0             | foo
id_3.0      | 3.0             | foo
id_2.0      | 2.0             | foo
id_1.0      | 1.0             | foo
;

fuseWithRowRRFAndMultiValueGroupColumn

required_capability: fuse_v6

ROW my_score = [0, 1, 2, 3, 4]::double, _index = "my_index", my_fork = "foo"
| MV_EXPAND my_score
| EVAL _id = CONCAT("id_", my_score::string), my_fork = CASE(my_score == 0, ["foo", "bar"], my_fork)
| SORT my_score
| LIMIT 10
| FUSE RRF SCORE BY my_score GROUP BY my_fork
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC
| KEEP _id, my_score, my_fork
;

warning:Line 6:3: evaluation of [FUSE RRF SCORE BY my_score GROUP BY my_fork] failed, treating result as null. Only first 20 failures recorded.
warning:Line 6:3: java.lang.IllegalArgumentException: group column contains multivalued entries; assigning null scores

_id:keyword | my_score:double | my_fork:keyword
id_0.0      | null            | [foo, bar]
id_1.0      | 0.01639         | foo
id_2.0      | 0.01613         | foo
id_3.0      | 0.01587         | foo
id_4.0      | 0.01563         | foo
;

fuseWithRowLinearL2NormAndZeroScores

required_capability: fuse_v6
required_capability: fuse_l2_norm

ROW _id = ["a", "b", "c"], _score = 0.0, _index = "my_index", my_fork = "foo"
| MV_EXPAND _id
| LIMIT 10
| FUSE LINEAR GROUP BY my_fork WITH { "normalizer": "l2_norm" }
| SORT _id
| KEEP _id, _score
;

_id:keyword | _score:double
a           | 0.0
b           | 0.0
c           | 0.0
;

fuseWithRowLinearMinMaxAndZeroScores

required_capability: fuse_v6

ROW _id = ["a", "b", "c"], _score = 0.0, _index = "my_index", my_fork = "foo"
| MV_EXPAND _id
| LIMIT 10
| FUSE LINEAR GROUP BY my_fork WITH { "normalizer": "minmax" }
| SORT _id
| KEEP _id, _score
;

_id:keyword | _score:double
a           | 0.0
b           | 0.0
c           | 0.0
;

fuseWithRowWithNullValues
required_capability: fuse_v6
required_capability: fix_agg_on_null_by_replacing_with_eval

ROW x = null, _id = "", _index = "", _score = 1.0, my_fork = ""
| LIMIT 1
| FUSE LINEAR GROUP BY my_fork
;

_score:double | x:null | _id:keyword | _index:keyword | my_fork:keyword
1             | null   | ""          | ""             | ""
;

fuseWithForkAndRowWithNullValues
required_capability: fork_v9
required_capability: fuse_v6
required_capability: fix_agg_on_null_by_replacing_with_eval

ROW x = null, _id = "", _index = "", _score = 1.0
| FORK (EVAl y = 2) (EVAl y = 3)
| FUSE LINEAR
| EVAL y = mv_sort(y), _fork = mv_sort(_fork)
;

_score:double | x:null | _id:keyword | _index:keyword | y:integer | _fork:keyword
2             | null   | ""          | ""             | [2, 3]    | [fork1,fork2]
;

fuseWithForkAndFromWithNullValues
required_capability: fork_v9
required_capability: fuse_v6
required_capability: fix_agg_on_null_by_replacing_with_eval

FROM employees METADATA _id, _index, _score
| EVAL x = null
| FORK ( WHERE emp_no:10001 )
       ( WHERE emp_no:10002 )
| FUSE
| KEEP x
;

x:null
null
;

fuseWithSubqueries
required_capability: subquery_in_from_command
required_capability: fuse_v6

FROM ( FROM employees METADATA _id, _index, _score
       | WHERE emp_no:10001 OR emp_no:10094
       | SORT emp_no DESC
       | LIMIT 10
       | EVAL label = "query1" ),
     ( FROM employees METADATA _id, _index, _score
     | WHERE emp_no:10002
     | SORT emp_no DESC
     | LIMIT 10
     | EVAL label = "query2" )
| FUSE GROUP BY label
| SORT _score DESC, emp_no
| EVAL _score = round(_score, 5)
| KEEP emp_no, _score, label
;

emp_no:integer | _score:double | label:keyword
10002          | 0.01639       | query2
10094          | 0.01639       | query1
10001          | 0.01613       | query1
;

fuseWithSubqueriesAndLookupJoin
required_capability: subquery_in_from_command
required_capability: join_lookup_v12
required_capability: fuse_v6

FROM ( FROM employees METADATA _id, _index, _score
       | WHERE emp_no:10001 OR  emp_no:10002
       | EVAL label = "query1" ),
     ( FROM employees METADATA _id, _index, _score
     | WHERE emp_no:10002
     | EVAL label = "query2" )
| LIMIT 10
| EVAL language_code = languages
| LOOKUP JOIN languages_lookup ON language_code
| FUSE LINEAR GROUP BY label
| SORT _score DESC, emp_no
| EVAL label = mv_sort(label)
| KEEP emp_no, _score, label, language_name, language_code
;

emp_no:integer | _score:double | label:keyword    | language_name:keyword | language_code:integer
10002          | 2.0           | [query1, query2] | null                  | 5
10001          | 1.0           | query1           | French                | 2
;

fuseWithRowAndLookupJoin
required_capability: join_lookup_v12
required_capability: fuse_v6

ROW language_code = [1, 2, 3, 4]
| MV_EXPAND language_code
| SORT language_code
| LIMIT 10
| LOOKUP JOIN languages_lookup ON language_code
| KEEP language_code, language_name
| EVAL label = CASE(language_code == 4, "label1", "label2"), my_score = 1.0
| FUSE GROUP BY label SCORE BY my_score KEY BY language_name
| EVAL my_score = round(my_score, 5)
| SORT my_score DESC, language_code
;

language_code:integer | language_name:keyword | label:keyword | my_score:double
1                     | English               | label2        | 0.01639
4                     | German                | label1        | 0.01639
2                     | French                | label2        | 0.01613
3                     | Spanish               | label2        | 0.01587
;

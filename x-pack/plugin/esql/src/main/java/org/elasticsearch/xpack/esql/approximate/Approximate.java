/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.esql.approximate;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.compute.data.LongBlock;
import org.elasticsearch.xpack.esql.core.InvalidArgumentException;
import org.elasticsearch.xpack.esql.core.expression.Alias;
import org.elasticsearch.xpack.esql.core.expression.Expression;
import org.elasticsearch.xpack.esql.core.expression.Literal;
import org.elasticsearch.xpack.esql.core.tree.Source;
import org.elasticsearch.xpack.esql.core.type.DataType;
import org.elasticsearch.xpack.esql.core.util.Holder;
import org.elasticsearch.xpack.esql.expression.function.aggregate.Count;
import org.elasticsearch.xpack.esql.plan.logical.Aggregate;
import org.elasticsearch.xpack.esql.plan.logical.Dissect;
import org.elasticsearch.xpack.esql.plan.logical.Drop;
import org.elasticsearch.xpack.esql.plan.logical.Eval;
import org.elasticsearch.xpack.esql.plan.logical.Filter;
import org.elasticsearch.xpack.esql.plan.logical.Fork;
import org.elasticsearch.xpack.esql.plan.logical.Grok;
import org.elasticsearch.xpack.esql.plan.logical.Keep;
import org.elasticsearch.xpack.esql.plan.logical.LeafPlan;
import org.elasticsearch.xpack.esql.plan.logical.LogicalPlan;
import org.elasticsearch.xpack.esql.plan.logical.OrderBy;
import org.elasticsearch.xpack.esql.plan.logical.Rename;
import org.elasticsearch.xpack.esql.plan.logical.Sample;
import org.elasticsearch.xpack.esql.plan.logical.join.Join;
import org.elasticsearch.xpack.esql.session.Result;

import java.util.List;
import java.util.Locale;
import java.util.Set;

/**
 * This class computes approximate and fast results for certain classes of
 * ES|QL queries.
 * <p>
 * A query is suitable for approximation if it contains at least one
 * {@code STATS} command, and all commands between the source and the leftmost
 * {@code STATS} command can be swapped with {@code SAMPLE}. A command can be
 * swapped with {@code SAMPLE} if it is either mapping one row to one row (e.g.
 * {@code EVAL} or {@code GROK}), or if it is filtering rows (e.g. {@code FILTER}
 * or {@code SAMPLE}). This is verified by {@link Approximate#verifyPlan}.
 * <p>
 * If this is the case, the {@code STATS} can be replaced by {@code SAMPLE} and
 * a {@code STATS} with sample correction terms, and the {@code SAMPLE} can be
 * moved to the source and executed inside Lucene. This new logical plan is
 * generated by {@link Approximate#approximatePlan}.
 * <p>
 * To compute the appropriate sample probability, first a target number of rows
 * is set. For now this is a fixed number ({@link Approximate#SAMPLE_ROW_COUNT}).
 * <p>
 * Next, the total number of rows in the source index is counted via the plan
 * {@link Approximate#sourceCountPlan}. This plan should execute fast. When
 * there are no filter commands, the sample probability can be directly
 * computed as a ratio of the target number of rows and this total number.
 * <p>
 * In the presence of filters commands, another step is needed. The initial
 * sample probability is set to the ratio above and the number of rows is
 * sampled with the plan {@link Approximate#countPlan}. As long as the sampled
 * number of rows is smaller than intended, the probability is scaled up until
 * a good probability is reached. This final probability is then used for
 * approximating the original plan.
 */
public class Approximate {

    public interface LogicalPlanRunner {
        void run(LogicalPlan plan, ActionListener<Result> listener);
    }

    /**
     * These commands can be swapped with {@code SAMPLE} and preserve all rows.
     */
    private static final Set<Class<? extends LogicalPlan>> SWAPPABLE_COMMANDS = Set.of(
        Dissect.class,
        Drop.class,
        Eval.class,
        Filter.class,
        Grok.class,
        Keep.class,
        OrderBy.class,
        Rename.class,
        Sample.class
    );

    /**
     * These commands can be swapped with {@code SAMPLE} and may drop rows.
     */
    private static final Set<Class<? extends LogicalPlan>> FILTER_COMMANDS = Set.of(Filter.class, Sample.class);

    /**
     * Commands that cannot be used anywhere in an approximated query.
     */
    private static final Set<Class<? extends LogicalPlan>> INCOMPATIBLE_COMMANDS = Set.of(Fork.class, Join.class);

    // TODO: find a good default value, or alternative ways of setting it
    private static final int SAMPLE_ROW_COUNT = 10000;

    private static final Logger logger = LogManager.getLogger(Approximate.class);

    private final LogicalPlan logicalPlan;
    private final boolean hasFilters;

    public Approximate(LogicalPlan logicalPlan) {
        this.logicalPlan = logicalPlan;
        this.hasFilters = verifyPlan();
    }

    /**
     * Computes approximate results for the logical plan.
     */
    public void approximate(LogicalPlanRunner runner, ActionListener<Result> listener) {
        runner.run(sourceCountPlan(), sourceCountListener(runner, listener));
    }

    /**
     * Verifies that a plan is suitable for approximation.
     *
     * @return whether the plan contains filters commands
     */
    private boolean verifyPlan() {
        if (logicalPlan.preOptimized() == false) {
            throw new IllegalStateException("Expected pre-optimized plan");
        }
        if (logicalPlan.anyMatch(plan -> plan instanceof Aggregate) == false) {
            throw new InvalidArgumentException("query without [STATS] command cannot be approximated");
        }
        logicalPlan.forEachUp(plan -> {
            if (INCOMPATIBLE_COMMANDS.contains(plan.getClass())) {
                throw new InvalidArgumentException(
                    "query with [" + plan.nodeName().toUpperCase(Locale.ROOT) + "] command cannot be approximated"
                );
            }
        });

        Holder<Boolean> encounteredStats = new Holder<>(false);
        Holder<Boolean> hasFilters = new Holder<>(false);
        logicalPlan.transformUp(plan -> {
            if (INCOMPATIBLE_COMMANDS.contains(plan.getClass())) {
                throw new InvalidArgumentException(
                    "query with [" + plan.nodeName().toUpperCase(Locale.ROOT) + "] command cannot be approximated"
                );
            } else if (plan instanceof LeafPlan) {
                encounteredStats.set(false);
            } else if (encounteredStats.get() == false) {
                if (plan instanceof Aggregate) {
                    encounteredStats.set(true);
                } else if (SWAPPABLE_COMMANDS.contains(plan.getClass()) == false && FILTER_COMMANDS.contains(plan.getClass()) == false) {
                    throw new InvalidArgumentException(
                        "query with [" + plan.nodeName().toUpperCase(Locale.ROOT) + "] before [STATS] command cannot be approximated"
                    );
                } else if (FILTER_COMMANDS.contains(plan.getClass())) {
                    hasFilters.set(true);
                }
            }
            return plan;
        });

        return hasFilters.get();
    }

    /**
     * Plan that counts the number of rows in the source index.
     * This is the ES|QL query {@code FROM index | STATS COUNT(*)}.
     */
    private LogicalPlan sourceCountPlan() {
        LogicalPlan sourceCountPlan = logicalPlan.transformUp(plan -> {
            if (plan instanceof LeafPlan) {
                plan = new Aggregate(
                    Source.EMPTY,
                    plan,
                    List.of(),
                    List.of(new Alias(Source.EMPTY, "approximate-count", new Count(Source.EMPTY, Literal.keyword(Source.EMPTY, "*"))))
                );
            } else {
                plan = plan.children().getFirst();
            }
            return plan;
        });

        sourceCountPlan.setPreOptimized();
        return sourceCountPlan;
    }

    /**
     * Receives the total number of rows, and runs either the
     * {@link Approximate#approximatePlan} or {@link Approximate#countPlan}
     * depending on whether filter commands are present.
     */
    private ActionListener<Result> sourceCountListener(LogicalPlanRunner runner, ActionListener<Result> listener) {
        return listener.delegateFailureAndWrap((countListener, countResult) -> {
            logger.debug("sourceCountPlan result: {} rows", rowCount(countResult));
            double sampleProbability = sampleProbability(countResult);
            countResult.pages().getFirst().close();
            if (hasFilters) {
                runner.run(countPlan(sampleProbability), countListener(runner, sampleProbability, listener));
            } else {
                runner.run(approximatePlan(sampleProbability), listener);
            }
        });
    }

    /**
     * Plan that counts the number of rows reaching the leftmost STATS function.
     * This is number is approximated to speed up the query execution.
     * This is the ES|QL query {@code FROM index | (...) | SAMPLE p | STATS COUNT(*) / p}.
     */
    private LogicalPlan countPlan(double sampleProbability) {
        Holder<Boolean> encounteredStats = new Holder<>(false);
        LogicalPlan countPlan = logicalPlan.transformUp(plan -> {
            if (plan instanceof LeafPlan) {
                encounteredStats.set(false);
            } else if (encounteredStats.get() == false) {
                if (plan instanceof Aggregate aggregate) {
                    encounteredStats.set(true);
                    Expression sampleProbabilityExpr = new Literal(Source.EMPTY, sampleProbability, DataType.DOUBLE);
                    Sample sample = new Sample(Source.EMPTY, sampleProbabilityExpr, aggregate.child());
                    plan = new Aggregate(
                        Source.EMPTY,
                        sample,
                        List.of(),
                        List.of(new Alias(Source.EMPTY, "approximate-count", new Count(Source.EMPTY, Literal.keyword(Source.EMPTY, "*"))))
                    );
                }
            } else {
                plan = plan.children().getFirst();
            }
            return plan;
        });

        countPlan.setPreOptimized();
        return countPlan;
    }

    /**
     * Receives the sampled number of rows reaching the leftmost STATS function.
     * Runs either the {@link Approximate#approximatePlan} or a next iteration
     * {@link Approximate#countPlan} depending on whether the current count is
     * sufficient.
     */
    private ActionListener<Result> countListener(LogicalPlanRunner runner, double probability, ActionListener<Result> listener) {
        return listener.delegateFailureAndWrap((countListener, countResult) -> {
            long rowCount = rowCount(countResult);
            logger.debug("countPlan result (p={}): {} rows", probability, rowCount);
            double newProbability = probability * SAMPLE_ROW_COUNT / Math.max(1, rowCount);
            countResult.pages().getFirst().close();
            if (rowCount <= SAMPLE_ROW_COUNT / 2 && newProbability < 1.0) {
                runner.run(countPlan(newProbability), countListener(runner, newProbability, listener));
            } else {
                runner.run(approximatePlan(newProbability), listener);
            }
        });
    }

    /**
     * Returns a sample probability based on the total number of rows.
     */
    private double sampleProbability(Result countResult) {
        long rowCount = rowCount(countResult);
        return rowCount <= SAMPLE_ROW_COUNT ? 1.0 : (double) SAMPLE_ROW_COUNT / rowCount;
    }

    /**
     * Returns the row count in the result.
     */
    private long rowCount(Result countResult) {
        return ((LongBlock) (countResult.pages().getFirst().getBlock(0))).getLong(0);
    }

    /**
     * Returns a plan that approximates the original plan. It consists of the
     * original plan, with the leftmost STATS function replaced by:
     * "SAMPLE probability | STATS sample_corrected_aggs".
     */
    private LogicalPlan approximatePlan(double sampleProbability) {
        if (sampleProbability >= 1.0) {
            logger.debug("using original plan (too few rows)");
            return logicalPlan;
        }
        logger.debug("generating approximate plan (p={})", sampleProbability);
        Holder<Boolean> encounteredStats = new Holder<>(false);
        LogicalPlan approximatePlan = logicalPlan.transformUp(plan -> {
            if (plan instanceof LeafPlan) {
                encounteredStats.set(false);
            } else if (encounteredStats.get() == false) {
                if (plan instanceof Aggregate aggregate) {
                    encounteredStats.set(true);
                    Expression sampleProbabilityExpr = new Literal(Source.EMPTY, sampleProbability, DataType.DOUBLE);
                    Sample sample = new Sample(Source.EMPTY, sampleProbabilityExpr, aggregate.child());
                    plan = aggregate.replaceChild(sample);
                    plan = plan.transformExpressionsOnlyUp(
                        expr -> expr instanceof NeedsSampleCorrection nsc ? nsc.sampleCorrection(sampleProbabilityExpr) : expr
                    );
                }
            }
            return plan;
        });

        approximatePlan.setPreOptimized();
        return approximatePlan;
    }
}

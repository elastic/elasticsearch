setup:
  - requires:
      cluster_features: "gte_v8.15.0"
      reason: semantic_text introduced in 8.15.0

  - do:
      inference.put:
        task_type: sparse_embedding
        inference_id: sparse-inference-id
        body: >
          {
            "service": "test_service",
            "service_settings": {
              "model": "my_model",
              "api_key": "abc64"
            },
            "task_settings": {
            }
          }

  - do:
      inference.put:
        task_type: text_embedding
        inference_id: dense-inference-id
        body: >
          {
            "service": "text_embedding_test_service",
            "service_settings": {
              "model": "my_model",
              "dimensions": 10,
              "similarity": "cosine",
              "api_key": "abc64"
            },
            "task_settings": {
            }
          }

  - do:
      indices.create:
        index: test-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: sparse-inference-id
              dense_field:
                type: semantic_text
                inference_id: dense-inference-id
              non_inference_field:
                type: text

---
"Calculates sparse embedding and text embedding results for new documents":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 22 }

---
"Calculates sparse embedding and text embedding results for new documents with integer value":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: 75
          dense_field: 100
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 2 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 3 }

---
"Calculates sparse embedding and text embedding results for new documents with boolean value":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: true
          dense_field: false
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 4 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 5 }

---
"Calculates sparse embedding and text embedding results for new documents with a collection of mixed data types":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: [false, 75, "inference test", 13.49]
          dense_field: [true, 49.99, "another inference test", 5654]
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 4 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 5 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.start_offset: 6 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.end_offset: 8 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.2.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.2.start_offset: 9 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.2.end_offset: 23 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.3.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.3.start_offset: 24 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.3.end_offset: 29 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 4 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 4 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.start_offset: 5 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.end_offset: 10 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.2.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.2.start_offset: 11 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.2.end_offset: 33 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.3.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.3.start_offset: 34 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.3.end_offset: 38 }

---
"Inference fields do not create new mappings":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"

  - do:
      indices.get_mapping:
        index: test-index

  - match: { test-index.mappings.properties.sparse_field.type: semantic_text }
  - match: { test-index.mappings.properties.dense_field.type: semantic_text }
  - match: { test-index.mappings.properties.non_inference_field.type: text }
  - length: { test-index.mappings.properties: 3 }

---
"Sparse vector results are indexed as nested chunks and searchable":
  - do:
      bulk:
        index: test-index
        refresh: true
        body: |
          {"index":{}}
          {"sparse_field": ["you know, for testing", "now with chunks"]}
          {"index":{}}
          {"sparse_field": ["some more tests", "that include chunks"]}

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            nested:
              path: sparse_field.inference.chunks
              query:
                sparse_vector:
                  field: sparse_field.inference.chunks.embeddings
                  inference_id: sparse-inference-id
                  query: "you know, for testing"

  - match: { hits.total.value: 2 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 2 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 21 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.start_offset: 22 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.end_offset: 37 }

  - length: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field: 2 }
  - exists: hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 15 }
  - exists: hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.embeddings
  - match: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.start_offset: 16 }
  - match: { hits.hits.1._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.end_offset: 35 }

---
"Dense vector results are indexed as nested chunks and searchable":
  - do:
      bulk:
        index: test-index
        refresh: true
        body: |
          {"index":{}}
          {"dense_field": ["you know, for testing", "now with chunks"]}
          {"index":{}}
          {"dense_field": ["some more tests", "that include chunks"]}

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            nested:
              path: dense_field.inference.chunks
              query:
                knn:
                  field: dense_field.inference.chunks.embeddings
                  query_vector_builder:
                    text_embedding:
                      model_id: dense-inference-id
                      model_text: "you know, for testing"

  - match: { hits.total.value: 2 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 2 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 21 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.start_offset: 22 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.1.end_offset: 37 }

  - length: { hits.hits.1._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field: 2 }
  - exists: hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 15 }
  - exists: hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.1.embeddings
  - match: { hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.1.start_offset: 16 }
  - match: { hits.hits.1._source._inference_fields.dense_field.inference.chunks.dense_field.1.end_offset: 35 }

---
"Reindex works for semantic_text fields":
  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"
        refresh: true

  - do:
      indices.create:
        index: destination-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: sparse-inference-id
              dense_field:
                type: semantic_text
                inference_id: dense-inference-id
              non_inference_field:
                type: text

  - do:
      reindex:
        wait_for_completion: true
        body:
          source:
            index: test-index
          dest:
            index: destination-index

  - do:
      indices.refresh: { }

  - do:
      get:
        index: destination-index
        id: doc_1

  - match: { _source.sparse_field: "inference test" }
  - match: { _source.dense_field: "another inference test" }
  - match: { _source.non_inference_field: "non inference test" }

  - do:
      search:
        index: destination-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 22 }

---
"Fails for non-existent inference":
  - do:
      indices.create:
        index: incorrect-test-index
        body:
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: non-existing-inference-id
              non_inference_field:
                type: text

  - do:
      catch: missing
      index:
        index: incorrect-test-index
        id: doc_1
        body:
          sparse_field: "inference test"
          non_inference_field: "non inference test"

  - match: { error.reason: "Inference id [non-existing-inference-id] not found for field [sparse_field]" }

  # Succeeds when semantic_text field is not used
  - do:
      index:
        index: incorrect-test-index
        id: doc_1
        body:
          non_inference_field: "non inference test"

---
"semantic_text copy_to calculates embeddings for source fields":
  - do:
      indices.create:
        index: test-copy-to-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: sparse-inference-id
              source_field:
                type: text
                copy_to: sparse_field
              another_source_field:
                type: text
                copy_to: sparse_field

  - do:
      index:
        index: test-copy-to-index
        id: doc_1
        body:
          source_field: "copy_to inference test"
          sparse_field: "inference test"
          another_source_field: "another copy_to inference test"
        refresh: true

  - do:
      search:
        index: test-copy-to-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 3 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.source_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.source_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.source_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.source_field.0.end_offset: 22 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.another_source_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.another_source_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.another_source_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.another_source_field.0.end_offset: 30 }

---
"Calculates embeddings for bulk operations - index":
  - do:
      bulk:
        body:
          - '{"index": {"_index": "test-index", "_id": "doc_1"}}'
          - '{"sparse_field": "inference test", "dense_field": "another inference test", "non_inference_field": "non inference test"}'
        refresh: true

  - match: { errors: false }
  - match: { items.0.index.result: "created" }

  - do:
      get:
        index: test-index
        id: doc_1

  - match: { _source.sparse_field: "inference test" }
  - match: { _source.dense_field: "another inference test" }
  - match: { _source.non_inference_field: "non inference test" }

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 22 }

---
"Update by query picks up new semantic_text fields":
  - do:
      indices.create:
        index: mapping-update-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            dynamic: false
            properties:
              non_inference_field:
                type: text

  - do:
      index:
        index: mapping-update-index
        id: doc_1
        refresh: true
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"

  - do:
      indices.put_mapping:
        index: mapping-update-index
        body:
          properties:
            sparse_field:
              type: semantic_text
              inference_id: sparse-inference-id
            dense_field:
              type: semantic_text
              inference_id: dense-inference-id
            non_inference_field:
              type: text

  - do:
      update_by_query:
        wait_for_completion: true
        index: mapping-update-index

  - match: { updated: 1 }

  - do:
      indices.refresh: { }

  - do:
      get:
        index: mapping-update-index
        id: doc_1

  - match: { _source.sparse_field: "inference test" }
  - match: { _source.dense_field: "another inference test" }
  - match: { _source.non_inference_field: "non inference test" }

  - do:
      search:
        index: mapping-update-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }

  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 22 }

---
"Update by query works for scripts":
  - do:
      index:
        index: test-index
        id: doc_1
        refresh: true
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 22 }

  - do:
      update_by_query:
        refresh: true
        wait_for_completion: true
        index: test-index
        body: { "script": "ctx._source.sparse_field = 'updated inference test'; ctx._source.dense_field = 'another updated inference test'" }

  - match: { updated: 1 }

  - do:
      get:
        index: test-index
        id: doc_1

  - match: { _source.sparse_field: "updated inference test" }
  - match: { _source.dense_field: "another updated inference test" }

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - length: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field: 1 }
  # We can't directly check that the embeddings are different since there isn't a "does not match" assertion in the
  # YAML test framework. Check that the start and end offsets change as expected as a proxy.
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 22 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.dense_field.inference.chunks.dense_field.0.end_offset: 30 }

---
"Calculates embeddings using the default ELSER 2 endpoint":
  - requires:
      reason: "default ELSER 2 inference ID is enabled via a capability"
      test_runner_features: [capabilities]
      capabilities:
        - method: GET
          path: /_inference
          capabilities: [default_elser_2]

  - do:
      indices.create:
        index: test-elser-2-default-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              sparse_field:
                type: semantic_text

  - do:
      index:
        index: test-elser-2-default-index
        id: doc_1
        body:
          sparse_field: "inference test"
        refresh: true

  - do:
      search:
        index: test-elser-2-default-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }

---
"Can be used inside an object field":
  - requires:
      cluster_features: "semantic_text.in_object_field_fix"
      reason: object field fix added in 8.16.0 & 8.15.4

  - do:
      indices.create:
        index: test-in-object-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              level_1:
                properties:
                  sparse_field:
                    type: semantic_text
                    inference_id: sparse-inference-id
                  dense_field:
                    type: semantic_text
                    inference_id: dense-inference-id

  - do:
      index:
        index: test-in-object-index
        id: doc_1
        body:
          level_1:
            sparse_field: "inference test"
            dense_field: "another inference test"
        refresh: true

  - do:
      get:
        index: test-in-object-index
        id: doc_1

  - match: { _source.level_1.sparse_field: "inference test" }
  - match: { _source.level_1.dense_field: "another inference test" }

  - do:
      search:
        index: test-in-object-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: {}

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }

  - length: { hits.hits.0._source._inference_fields.level_1\\.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.level_1\\.sparse_field.inference.chunks.level_1\\.sparse_field: 1 }
  - exists: hits.hits.0._source._inference_fields.level_1\\.sparse_field.inference.chunks.level_1\\.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.level_1\\.sparse_field.inference.chunks.level_1\\.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.level_1\\.sparse_field.inference.chunks.level_1\\.sparse_field.0.end_offset: 14 }

  - length: { hits.hits.0._source._inference_fields.level_1\\.dense_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.level_1\\.dense_field.inference.chunks.level_1\\.dense_field: 1 }
  - exists: hits.hits.0._source._inference_fields.level_1\\.dense_field.inference.chunks.level_1\\.dense_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.level_1\\.dense_field.inference.chunks.level_1\\.dense_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.level_1\\.dense_field.inference.chunks.level_1\\.dense_field.0.end_offset: 22 }

---
"Deletes on bulk operation":
  - requires:
      cluster_features: semantic_text.delete_fix
      reason: Delete operations are properly applied when subsequent operations include a semantic text field.

  - do:
      bulk:
        index: test-index
        refresh: true
        body: |
          {"index":{"_id": "1"}}
          {"dense_field": ["you know, for testing", "now with chunks"]}
          {"index":{"_id": "2"}}
          {"dense_field": ["some more tests", "that include chunks"]}

  - do:
      search:
        index: test-index
        body:
          query:
            semantic:
              field: dense_field
              query: "you know, for testing"

  - match: { hits.total.value: 2 }
  - match: { hits.total.relation: eq }
  - match: { hits.hits.0._source.dense_field: ["you know, for testing", "now with chunks"] }
  - match: { hits.hits.1._source.dense_field: ["some more tests", "that include chunks"] }

  - do:
      bulk:
        index: test-index
        refresh: true
        body: |
          {"delete":{ "_id": "2"}}
          {"update":{"_id": "1"}}
          {"doc":{"dense_field": "updated text"}}

  - do:
      search:
        index: test-index
        body:
          query:
            semantic:
              field: dense_field
              query: "you know, for testing"

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }
  - match: { hits.hits.0._source.dense_field: "updated text" }

---
"Multi-fields support":

  - do:
      indices.create:
        index: test-multi-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              field:
                type: text
                fields:
                  sparse:
                    type: semantic_text
                    inference_id: sparse-inference-id
                  dense:
                    type: semantic_text
                    inference_id: dense-inference-id
              non_inference_field:
                type: text

  - do:
      bulk:
        index: test-multi-index
        refresh: true
        body: |
          {"index":{"_id": "1"}}
          {"field": ["you know, for testing", "now with chunks"]}
          {"index":{"_id": "2"}}
          {"field": ["some more tests", "that include chunks"]}

  - do:
      search:
        index: test-multi-index
        body:
          query:
            semantic:
              field: field.sparse
              query: "you know, for testing"
          highlight:
            fields:
              "field.sparse": {
                "type": "semantic",
                "number_of_fragments": 2
              }

  - match:  { hits.total.value: 2 }
  - match:  { hits.total.relation: eq }
  - length: { hits.hits.0.highlight.field\.sparse: 2 }
  - match:  { hits.hits.0.highlight.field\.sparse.0: "you know, for testing" }
  - match:  { hits.hits.0.highlight.field\.sparse.1: "now with chunks" }
  - length: { hits.hits.1.highlight.field\.sparse: 2 }
  - match:  { hits.hits.1.highlight.field\.sparse.0: "some more tests" }
  - match:  { hits.hits.1.highlight.field\.sparse.1: "that include chunks" }

  - do:
      search:
        index: test-multi-index
        body:
          query:
            semantic:
              field: field.dense
              query: "you know, for testing"
          highlight:
            fields:
              "field.dense": {
                "type": "semantic",
                "number_of_fragments": 2
              }

  - match:  { hits.total.value: 2 }
  - match:  { hits.total.relation: eq }
  - length: { hits.hits.0.highlight.field\.dense: 2 }
  - match:  { hits.hits.0.highlight.field\.dense.0: "you know, for testing" }
  - match:  { hits.hits.0.highlight.field\.dense.1: "now with chunks" }
  - length: { hits.hits.1.highlight.field\.dense: 2 }
  - match:  { hits.hits.1.highlight.field\.dense.0: "some more tests" }
  - match:  { hits.hits.1.highlight.field\.dense.1: "that include chunks" }

  - do:
      search:
        index: test-multi-index
        body:
          query:
            match:
              field: "you know tests, with chunks"
          highlight:
            fields:
              field:
                number_of_fragments: 2

  - match:  { hits.total.value: 2 }
  - match:  { hits.total.relation: eq }
  - length: { hits.hits.0.highlight.field: 2 }
  - match:  { hits.hits.0.highlight.field.0: "<em>you</em> <em>know</em>, for testing" }
  - match:  { hits.hits.0.highlight.field.1: "now <em>with</em> <em>chunks</em>" }
  - length: { hits.hits.1.highlight.field: 2 }
  - match:  { hits.hits.1.highlight.field.0: "some more <em>tests</em>" }
  - match:  { hits.hits.1.highlight.field.1: "that include <em>chunks</em>" }

---
"Inference metadata fields format is used by default":
  - requires:
      cluster_features: "semantic_text.inference_metadata_fields.enabled_by_default"
      reason: Inference metadata fields format is used by default as of 8.18

  - do:
      indices.create:
        index: default-index
        body:
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: sparse-inference-id
              dense_field:
                type: semantic_text
                inference_id: dense-inference-id
              non_inference_field:
                type: text

  - do:
      index:
        index: default-index
        id: doc_1
        body:
          sparse_field: "inference test"
          dense_field: "another inference test"
          non_inference_field: "non inference test"
        refresh: true

  - do:
      search:
        index: default-index
        body:
          query:
            semantic:
              field: sparse_field
              query: "inference test"
          fields: [ "_inference_fields" ]

  - match: { hits.total.value: 1 }
  - match: { hits.total.relation: eq }
  - match: { hits.hits.0._source.sparse_field: "inference test" }
  - match: { hits.hits.0._source.dense_field: "another inference test" }
  - match: { hits.hits.0._source.non_inference_field: "non inference test" }
  - exists: hits.hits.0._source._inference_fields

---
"Empty semantic_text field skips embedding generation":
  - requires:
      cluster_features: "semantic_text.handle_empty_input"
      reason: Skips embedding generation when semantic_text is empty or contains only whitespace, effective from 8.19 and 9.1.0.

  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: ""
        refresh: true

  - do:
      index:
        index: test-index
        id: doc_2
        body:
          sparse_field: "   "
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: { }

  - match: { hits.total.value: 2 }
  - match: { hits.hits.0._source.sparse_field: "" }
  - match: { hits.hits.1._source.sparse_field: "   " }
  - not_exists: hits.hits.0._source._inference_fields
  - not_exists: hits.hits.1._source._inference_fields

---
"Reindexing with empty or whitespace semantic_text skips embedding generation":
  - requires:
      cluster_features: "semantic_text.handle_empty_input"
      reason: Skips embedding generation when semantic_text is empty or contains only whitespace, effective from 8.19 and 9.1.0.

  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: "  "
        refresh: true

  - do:
      indices.create:
        index: destination-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              sparse_field:
                type: semantic_text
                inference_id: sparse-inference-id

  - do:
      reindex:
        wait_for_completion: true
        body:
          source:
            index: test-index
          dest:
            index: destination-index
        refresh: true

  - do:
      get:
        index: destination-index
        id: doc_1

  - match: { _source.sparse_field: "  " }

  - do:
      search:
        index: destination-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: { }

  - not_exists: hits.hits.0._source._inference_fields

---
"Empty Multi-Field skips embedding generation":
  - requires:
      cluster_features: "semantic_text.handle_empty_input"
      reason: Skips embedding generation when semantic_text is empty or contains only whitespace, effective from 8.19 and 9.1.0.

  - do:
      indices.create:
        index: test-multi-index
        body:
          settings:
            index:
              mapping:
                semantic_text:
                  use_legacy_format: false
          mappings:
            properties:
              field:
                type: semantic_text
                inference_id: sparse-inference-id
                fields:
                  sparse:
                    type: semantic_text
                    inference_id: sparse-inference-id

  - do:
      bulk:
        index: test-multi-index
        refresh: true
        body: |
          {"index":{"_id": "1"}}
          {"field": ["you know, for testing", "now with chunks"]}
          {"index":{"_id": "2"}}
          {"field": ["", "  "]}

  - do:
      search:
        index: test-multi-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: { }

  - exists: hits.hits.0._source._inference_fields
  - not_exists: hits.hits.1._source._inference_fields

---
"Multi chunks skips empty input embedding generation":
  - requires:
      cluster_features: "semantic_text.handle_empty_input"
      reason: Skips embedding generation when semantic_text is empty or contains only whitespace, effective from 8.19 and 9.1.0.

  - do:
      index:
        index: test-index
        id: doc_1
        body:
          sparse_field: ["some test data", "    ", "now with chunks"]
        refresh: true

  - do:
      search:
        index: test-index
        body:
          fields: [ _inference_fields ]
          query:
            match_all: { }

  - match: { hits.total.value: 1 }

  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks: 1 }
  - length: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field: 2 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.start_offset: 0 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.0.end_offset: 14 }
  - exists: hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.embeddings
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.start_offset: 20 }
  - match: { hits.hits.0._source._inference_fields.sparse_field.inference.chunks.sparse_field.1.end_offset: 35 }

---
"inference endpoint late creation":
  - do:
      indices.create:
        index: new-index
        body:
          mappings:
            properties:
              inference_field:
                type: semantic_text
                inference_id: new_inference_endpoint

  - do:
      inference.put:
        task_type: sparse_embedding
        inference_id: new_inference_endpoint
        body: >
          {
            "service": "test_service",
            "service_settings": {
              "model": "my_model",
              "api_key": "abc64"
            },
            "task_settings": {
            }
          }
  - do:
      index:
        index: new-index
        id: doc_1
        body:
          inference_field: "inference test"
        refresh: true

  - do:
      search:
        index: new-index
        body:
          query:
            exists:
              field: "inference_field"

  - match: { hits.total.value: 1 }


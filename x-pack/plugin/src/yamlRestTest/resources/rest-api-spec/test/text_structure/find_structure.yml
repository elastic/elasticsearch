setup:
  - skip:
      features: headers
---
"Test NDJSON file structure analysis without overrides":
  - do:
      headers:
        # This is to stop the usual content type randomization,
        # which would obviously ruin the results for this particular test
        Content-Type: "application/json"
      text_structure.find_structure:
        lines_to_sample: 3
        line_merge_size_limit: 1234
        timeout: 10s
        body:
          - airline: AAL
            responsetime: 132.2046
            sourcetype: text-structure-test
            time: 1403481600
          - airline: JZA
            responsetime: 990.4628
            sourcetype: text-structure-test
            time: 1403481700
          - airline: AAL
            responsetime: 134.2046
            sourcetype: text-structure-test
            time: 1403481800

  - match: { num_lines_analyzed: 3 }
  - match: { num_messages_analyzed: 3 }
  - match: { charset: "UTF-8" }
  - match: { has_byte_order_marker: false }
  - match: { format: ndjson }
  - match: { timestamp_field: time }
  - match: { joda_timestamp_formats.0: UNIX }
  - match: { java_timestamp_formats.0: UNIX }
  - match: { need_client_timezone: false }
  - match: { mappings.properties.airline.type: keyword }
  - match: { mappings.properties.responsetime.type: double }
  - match: { mappings.properties.sourcetype.type: keyword }
  - match: { mappings.properties.time.type: date }
  - match: { mappings.properties.time.format: epoch_second }
  - match: { ingest_pipeline.description: "Ingest pipeline created by text structure finder" }
  - match: { ingest_pipeline.processors.0.date.field: time }
  - match: { ingest_pipeline.processors.0.date.formats.0: UNIX }
  - match: { field_stats.airline.count: 3 }
  - match: { field_stats.airline.cardinality: 2 }
  - match: { field_stats.responsetime.count: 3 }
  - match: { field_stats.responsetime.cardinality: 3 }
  - match: { field_stats.responsetime.min_value: 132.2046 }
  - match: { field_stats.responsetime.max_value: 990.4628 }
  # Not asserting on field_stats.responsetime.mean as it's a recurring decimal
  # so its representation in the response could cause spurious failures
  - match: { field_stats.responsetime.median_value: 134.2046 }
  - match: { field_stats.sourcetype.count: 3 }
  - match: { field_stats.sourcetype.cardinality: 1 }
  - match: { field_stats.time.count: 3 }
  - match: { field_stats.time.cardinality: 3 }
  - match: { field_stats.time.earliest: "1403481600" }
  - match: { field_stats.time.latest: "1403481800" }
  - is_false: explanation

---
"Test NDJSON file structure analysis with overrides":
  - do:
      headers:
        # This is to stop the usual content type randomization,
        # which would obviously ruin the results for this particular test
        Content-Type: "application/json"
      text_structure.find_structure:
        charset: UTF-8
        format: ndjson
        timestamp_field: time
        timestamp_format: UNIX
        explain: true
        body:
          - airline: AAL
            responsetime: 132.2046
            sourcetype: text-structure-test
            time: 1403481600
          - airline: JZA
            responsetime: 990.4628
            sourcetype: text-structure-test
            time: 1403481700
          - airline: AAL
            responsetime: 134.2046
            sourcetype: text-structure-test
            time: 1403481800

  - match: { num_lines_analyzed: 3 }
  - match: { num_messages_analyzed: 3 }
  - match: { charset: "UTF-8" }
  - match: { has_byte_order_marker: false }
  - match: { format: ndjson }
  - match: { timestamp_field: time }
  - match: { joda_timestamp_formats.0: UNIX }
  - match: { java_timestamp_formats.0: UNIX }
  - match: { need_client_timezone: false }
  - match: { mappings.properties.airline.type: keyword }
  - match: { mappings.properties.responsetime.type: double }
  - match: { mappings.properties.sourcetype.type: keyword }
  - match: { mappings.properties.time.type: date }
  - match: { mappings.properties.time.format: epoch_second }
  - match: { ingest_pipeline.description: "Ingest pipeline created by text structure finder" }
  - match: { ingest_pipeline.processors.0.date.field: time }
  - match: { ingest_pipeline.processors.0.date.formats.0: UNIX }
  - match: { field_stats.airline.count: 3 }
  - match: { field_stats.airline.cardinality: 2 }
  - match: { field_stats.responsetime.count: 3 }
  - match: { field_stats.responsetime.cardinality: 3 }
  - match: { field_stats.responsetime.min_value: 132.2046 }
  - match: { field_stats.responsetime.max_value: 990.4628 }
  # Not asserting on field_stats.responsetime.mean as it's a recurring decimal
  # so its representation in the response could cause spurious failures
  - match: { field_stats.responsetime.median_value: 134.2046 }
  - match: { field_stats.sourcetype.count: 3 }
  - match: { field_stats.sourcetype.cardinality: 1 }
  - match: { field_stats.time.count: 3 }
  - match: { field_stats.time.cardinality: 3 }
  - match: { field_stats.time.earliest: "1403481600" }
  - match: { field_stats.time.latest: "1403481800" }
  - match: { explanation.0: "Using specified character encoding [UTF-8]" }

---
"Test invalid charset":
  - do:
      catch: bad_request
      headers:
        # This is to stop the usual content type randomization,
        # which would obviously ruin the results for this particular test
        Content-Type: "application/json"
      text_structure.find_structure:
        charset: wrong
        body:
          - airline: AAL
            responsetime: 132.2046
            sourcetype: text-structure-test
            time: 1403481600
---
"Test yyyy/MM/dd HH:mm:ss format":
  - do:
      headers:
        Content-Type: "application/x-ndjson"
      text_structure.find_structure:
        body: "2025/07/10 10:30:35 some message\n2025/07/10 10:30:36 another message\n2025/07/10 10:30:37 final message"

  - match: { num_lines_analyzed: 3 }
  - match: { num_messages_analyzed: 3 }
  - match: { charset: "UTF-8" }
  - match: { has_byte_order_marker: false }
  - match: { format: "delimited" }
  - match: { grok_pattern: "% {TIMESTAMP_CUSTOM:timestamp} %{GREEDYDATA:message}" }
  - match: { timestamp_field: "timestamp" }
  - match: { java_timestamp_formats.0: "yyyy/MM/dd HH:mm:ss" }
  - match: { need_client_timezone: true }
  - match: { mappings.properties.message.type: "text" }
  - match: { mappings.properties.timestamp.type: "date" }
  - match: { mappings.properties.timestamp.format: "yyyy/MM/dd HH:mm:ss" }
  - match: { ingest_pipeline.description: "Ingest pipeline created by text structure finder" }
  - match: { ingest_pipeline.processors.0.grok.field: "message" }
  - match: { ingest_pipeline.processors.0.grok.patterns.0: "% {TIMESTAMP_CUSTOM:timestamp} %{GREEDYDATA:message}" }
  - match: { ingest_pipeline.processors.1.date.field: "timestamp" }
  - match: { ingest_pipeline.processors.1.date.formats.0: "yyyy/MM/dd HH:mm:ss" }
  - match: { field_stats.message.count: 3 }
  - match: { field_stats.message.cardinality: 3 }
  - match: { field_stats.timestamp.count: 3 }
  - match: { field_stats.timestamp.cardinality: 3 }
  - match: { field_stats.timestamp.earliest: "2025-07-10T10:30:35.000Z" }
  - match: { field_stats.timestamp.latest: "2025-07-10T10:30:37.000Z" }
  - is_false: explanation
